# Machine Learning Framework
from dataset import Dataset
from featureExtractionForCuckooJSON import CuckooJsonFeatureExtractor
from featureExtractionForMIST import MistFeatureExtractor
from decisionTreeClassifier import DecisionTreeClassifier
from randomForestClassifier import RandomForestClassifier
from benchmarkClassifier import *  # as bC

# from subprocess import Popen
# import subprocess
# import os

DATA_MANAGER = Dataset()  # Handles loading the data set.

CLASSIFIER = None  # Classifier being used.

TRAINING_SET_SIZE = 0  # This float determines the size of the training set. # Unused.

# Dictionary containing arrays with the partitioned data.
PARTITIONED_DATA_DICT = {
    "Training data": [],
    "Testing data": [],
    "Training labels": [],
    "Testing labels": []
}

# Dictionary containing all the available feature extractors.
EXTRACTOR_DICT = {
    "Cuckoo JSON": CuckooJsonFeatureExtractor,
    "MIST": MistFeatureExtractor
}

# Dictionary containing all the available classifiers.
CLASSIFIER_DICT = {
    "Decision Tree": DecisionTreeClassifier,
    "Random Forest": RandomForestClassifier
}


# Dictionary containing all benchmark functions.
BENCHMARKS_DICT = {
    # "Time MIST": time_mist_extraction,
    # "Time JSON": time_json_extraction,
    # "Time classifier": time_classifier,
    "Multiple malware rates": multiple_malware_rates,
    "Fixed malware rates": fixed_malware_rate
}


def feature_extraction(extraction_type):
    """
    Selects the appropriate feature extraction algorithm from the extraction dictionary
    according to extraction_type and runs it.
    :except KeyError: when extraction_type is not in EXTRACTOR_DICT.
    :param extraction_type: Type of feature extraction to be performed as String.
    :return: None.
    """
    try:
        extractor = EXTRACTOR_DICT[extraction_type]()
        extractor.extract_features()

    except KeyError:
        print(f"Feature extraction type {extraction_type} is not available.")


def load_json_data(malware_rate):
    """
    Loads the json data set from the csv file into memory.
    :param malware_rate: The amount of malware present in the data represented as a float.
    :return: None.
    """
    DATA_MANAGER.load_data(malware_rate)


def partition_data(size_of_test_set):
    """
    Partition the data into training and testing sets.
    :param size_of_test_set: Float representing the size of the testing set.
    :return: None.
    """
    PARTITIONED_DATA_DICT["Training data"], PARTITIONED_DATA_DICT["Testing data"], \
        PARTITIONED_DATA_DICT["Training labels"], PARTITIONED_DATA_DICT["Testing labels"] = \
        DATA_MANAGER.partition_data(size_of_test_set)


def select_classifier(classifier_name):
    """
    Selects the appropriate classifier from CLASSIFIER_DICT and instantiates it.
    :except KeyError: if classifier_name is not in CLASSIFIER_DICT.
    :param classifier_name: String representing the name of the classifier to select.
    :return: None.
    """
    try:
        global CLASSIFIER
        CLASSIFIER = CLASSIFIER_DICT[classifier_name]()

    except KeyError:
        print(f"Classifier {classifier_name} is not available.")

    else:
        return classifier_name  # Only return classifier_name if nothing goes wrong.


def train_classifier():
    """
    Trains the classifier.
    :return: None or classifier_does_not_exist_error message.
    """
    if CLASSIFIER:
        CLASSIFIER.fit(PARTITIONED_DATA_DICT["Training data"], PARTITIONED_DATA_DICT["Training labels"])
    return classifier_does_not_exist_error()


def classify_new_data():
    """
    :return: Returns the predicted labels in a list.
    """
    if CLASSIFIER:
        CLASSIFIER.predict(PARTITIONED_DATA_DICT["Testing data"])
        return CLASSIFIER.predicted_labels

    return classifier_does_not_exist_error()


def calculate_classifier_accuracy():
    """
    sklearn.exceptions.NotFittedError: This DecisionTreeClassifier instance is not fitted yet.
    Call 'fit' with appropriate arguments before using this method.
    :return: Returns the classifier's accuracy as a float.
    """
    if CLASSIFIER:
        CLASSIFIER.calculate_accuracy(PARTITIONED_DATA_DICT["Testing data"], PARTITIONED_DATA_DICT["Testing labels"])
        return CLASSIFIER.accuracy

    return classifier_does_not_exist_error()


def cross_validate(k_fold):  # return error code?
    """
    ValueError: Found array with 0 sample(s) (shape=(0,)) while a minimum of 1 is required. (no data loaded)

    Classify data using cross validation.
    :param k_fold: integer representing the number of partitions applied during cross validation.
    :return: The cross validation score as a list of lists.
    """
    if CLASSIFIER:

        try:
            CLASSIFIER.cross_validate(DATA_MANAGER.features, DATA_MANAGER.labels, k_fold)
            return CLASSIFIER.cross_score

        except ValueError:
            return "k_fold value must be an integer."

    return classifier_does_not_exist_error()


def display_confusion_matrix():
    """
    Plots the confusion matrix as an image.
    :return: None.
    """
    if CLASSIFIER:
        CLASSIFIER.display_confusion_matrix(PARTITIONED_DATA_DICT["Testing labels"], DATA_MANAGER.label_names)

    return classifier_does_not_exist_error()


def classifier_does_not_exist_error():  # Is this necessary ?
    return "Error: Could not perform operation because no classifier is selected. " \
           "Please select a classifier from the classifier menu."


def run_selected_benchmark(benchmark_type, *args):
    """
    Runs the selected benchmark function according to benchmark_type.
    :except TypeError: is thrown if number of arguments does not match required amount.
    :except KeyError: is thrown if selected function does not exist in dictionary.
    :param benchmark_type: benchmark name as String.
    :return: None.
    """
    try:
        params = [0] * len(args)

        params[0] = float(args[0])
        params[1] = float(args[1])
        params[2] = args[2]

        BENCHMARKS_DICT[benchmark_type](DATA_MANAGER, *params, CLASSIFIER)

    except TypeError:
        print(f"Error: {benchmark_type} does not take {len(args)} arguments.")

    except KeyError:
        print(f"Error: Could not perform operation because no benchmark of type {benchmark_type} exists. "
              f"Please select a valid benchmark option.")

    except ValueError:
        print("Error: Arguments must be floatinf point values")


def cuckoo_sandbox():
    """
    :return:
    """
    print("No implemented!")  # TODO: make it possible to launch cuckoo in another terminal from this program.
    #fifo = "fifo"    /home/marcus/PycharmProjects/Final_Project/launchCuckoo.py
    #os.mkfifo(fifo)
    #cuckoo_terminal = True
    #subprocess.Popen(["gnome-terminal", "--=echo 'test'"])
    #with open(fifo, "wb") as pipe:
    #    pipe.write()
    #os.system("./home/marcus/PycharmProjects/Final_Project/launchCuckoo.sh &")
    # subprocess.run("/home/marcus/PycharmProjects/Final_Project/launchCuckoo.sh")
    #cmd_line = "/home/marcus/PycharmProjects/Final_Project/launchCuckoo.sh"
    #p = subprocess.Popen(cmd_line, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    #new_terminal = subprocess.Popen("/home/marcus/PycharmProjects/Final_Project/launchCuckoo.sh", shell=True, stdout=subprocess.STDOUT, stderr=subprocess.STDOUT)
    #out = new_terminal.communicate()[0]
    #print(out)
    #outs, errs = new_terminal.communicate(input="/home/marcus/PycharmProjects/Final_Project/launchCuckoo.sh")
    #print(f"{outs}, {errs}")
    #subprocess.run(["gnome-terminal", "./home/marcus/PycharmProjects/Final_Project/launchCuckoo.sh &"])
    #subprocess.run()
    #subprocess.run("./load Cuckoo.sh")


def exception_handler():
    return

# cuckoo sandbox
#malware_rate = 0.01
#test_set_size = 0.33
#k_fold = 5
#high_malware_rates = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1]
#low_malware_rates = [0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08, 0.09, 0.1]
