# Machine Learning Framework
from dataset import Dataset
from featureExtractionForCuckooJSON import CuckooJsonFeatureExtractor
from featureExtractionForMIST import MistFeatureExtractor
from decisionTreeClassifier import DecisionTreeClassifier
from randomForestClassifier import RandomForestClassifier
from benchmarkClassifier import *

import subprocess

DATA_MANAGER = Dataset()  # Handles loading the data set.

CLASSIFIER = None  # Classifier being used.

TRAINING_SET_SIZE = 0  # This float determines the size of the training set. # Unused.

# Dictionary containing arrays with the partitioned data.
PARTITIONED_DATA_DICT = {
    "Training data": [],
    "Testing data": [],
    "Training labels": [],
    "Testing labels": []
}

# Dictionary containing all the available feature extractors.
EXTRACTOR_DICT = {
    "Cuckoo JSON": CuckooJsonFeatureExtractor,
    "MIST": MistFeatureExtractor
}

# Dictionary containing all the available classifiers.
CLASSIFIER_DICT = {
    "Decision Tree": DecisionTreeClassifier,
    "Random Forest": RandomForestClassifier
}


# Dictionary containing all benchmark functions.
BENCHMARKS_DICT = {
    "Time MIST": time_mist_extraction,
    "Time JSON": time_json_extraction,
    "Time classifier": time_classifier,
    "Multiple malware rates": multiple_malware_rates,
    "Fixed malware rates": fixed_malware_rate
}


def feature_extraction(extraction_type):
    """
    Selects the appropriate feature extraction algorithm from the extraction dictionary
    according to extraction_type and runs it.
    :except KeyError: when extraction_type is not in EXTRACTOR_DICT.
    :param extraction_type: Type of feature extraction to be performed as String.
    :return: None.
    """
    try:
        extractor = EXTRACTOR_DICT[extraction_type]()
        extractor.extract_features()

    except KeyError:
        print(f"Feature extraction type {extraction_type} is not available.")


def load_json_data(malware_rate):
    """
    Loads the json data set from the csv file into memory.
    :param malware_rate: The amount of malware present in the data represented as a float.
    :return: None.
    """
    DATA_MANAGER.load_data(malware_rate)


def partition_data(size_of_test_set):
    """
    Partition the data into training and testing sets.
    :param size_of_test_set: Float representing the size of the testing set.
    :return: None.
    """
    PARTITIONED_DATA_DICT["Training data"], PARTITIONED_DATA_DICT["Testing data"], \
        PARTITIONED_DATA_DICT["Training labels"], PARTITIONED_DATA_DICT["Testing labels"] = \
        DATA_MANAGER.partition_data(size_of_test_set)


def select_classifier(classifier_name):
    """
    Selects the appropriate classifier from CLASSIFIER_DICT and instantiates it.
    :except KeyError: if classifier_name is not in CLASSIFIER_DICT.
    :param classifier_name: String representing the name of the classifier to select.
    :return: None.
    """
    try:
        global CLASSIFIER
        CLASSIFIER = CLASSIFIER_DICT[classifier_name]()

    except KeyError:
        print(f"Classifier {classifier_name} is not available.")


def train_classifier():
    """
    Trains the classifier.
    :return: None or classifier_does_not_exist_error message.
    """
    if CLASSIFIER:
        CLASSIFIER.fit(PARTITIONED_DATA_DICT["Training data"], PARTITIONED_DATA_DICT["Training labels"])
    return classifier_does_not_exist_error()


def classify_new_data():
    """
    :return: Returns the predicted labels in a list.
    """
    if CLASSIFIER:
        CLASSIFIER.predict(PARTITIONED_DATA_DICT["Testing data"])
        return CLASSIFIER.predicted_labels

    return classifier_does_not_exist_error()


def calculate_classifier_accuracy():
    """
    :return: Returns the classifier's accuracy as a float.
    """
    if CLASSIFIER:
        CLASSIFIER.calculate_accuracy(PARTITIONED_DATA_DICT["Testing data"], PARTITIONED_DATA_DICT["Testing labels"])
        return CLASSIFIER.accuracy

    return classifier_does_not_exist_error()


def cross_validate(k_fold):
    """
    Classify data using cross validation.
    :param k_fold: integer representing the number of partitions applied during cross validation.
    :return: The cross validation score as a list of lists.
    """
    if CLASSIFIER:
        CLASSIFIER.cross_validate(DATA_MANAGER.features, DATA_MANAGER.labels, k_fold)
        return CLASSIFIER.cross_score

    return classifier_does_not_exist_error()


def display_confusion_matrix():
    """
    Plots the confusion matrix as an image.
    :return: None.
    """
    if CLASSIFIER:
        CLASSIFIER.display_confusion_matrix(PARTITIONED_DATA_DICT["Testing data"], DATA_MANAGER.label_names)

    return classifier_does_not_exist_error()


# TODO: Add instructions on how to select a classifier.
def classifier_does_not_exist_error():
    return "Error: Could not perform operation because no classifier is selected. Please select a classifier."


def run_selected_benchmark(benchmark_type, *args):
    """
    Runs the selected benchmark function according to benchmark_type.
    :except TypeError: is thrown if number of arguments does not match required amount.
    :except KeyError: is thrown if selected function does not exist in dictionary.
    :param benchmark_type: benchmark name as String.
    :return: None.
    """
    try:
        BENCHMARKS_DICT[benchmark_type](*args)

    except TypeError:
        print(f"Error: {benchmark_type} does not take {len(args)} amount of arguments.")

    except KeyError:
        print(f"Error: Could not perform operation because no benchmark of type {benchmark_type} exists. "
              f"Please select a valid benchmark option.")


def load_cuckoo():
    """
    :return:
    """
    subprocess.call("./load Cuckoo.sh")


#malware_rate = 0.01
#test_set_size = 0.33
#k_fold = 5
#high_malware_rates = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1]
#low_malware_rates = [0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08, 0.09, 0.1]
