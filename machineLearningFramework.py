# Machine Learning Framework
from dataset import Dataset
from featureExtractionForCuckooJSON import CuckooJsonFeatureExtractor
from featureExtractionForMIST import MistFeatureExtractor
from decisionTreeClassifier import DecisionTreeClassifier
from randomForestClassifier import RandomForestClassifier
from benchmarkClassifier import *  # as bC
from sklearn.exceptions import NotFittedError
from report import Report
# import report as rep
# from subprocess import Popen
import subprocess
import pickle
import os

DATA_MANAGER = Dataset()  # Handles loading the data set.

REPORT = Report()

CLASSIFIER = None  # Classifier being used.

TRAINING_SET_SIZE = 0  # This float determines the size of the training set. # Unused.

# Dictionary containing arrays with the partitioned data.
PARTITIONED_DATA_DICT = {
    "Training data": [],
    "Testing data": [],
    "Training labels": [],
    "Testing labels": []
}

# Dictionary containing all the available feature extractors.
EXTRACTOR_DICT = {
    "Cuckoo JSON": CuckooJsonFeatureExtractor,
    "MIST": MistFeatureExtractor
}

# Dictionary containing all the available classifiers.
CLASSIFIER_DICT = {
    "Decision Tree": DecisionTreeClassifier,
    "Random Forest": RandomForestClassifier
}


# Dictionary containing all benchmark functions.
BENCHMARKS_DICT = {
    # "Time MIST": time_mist_extraction,
    # "Time JSON": time_json_extraction,
    # "Time classifier": time_classifier,
    "Multiple malware rates": multiple_malware_rates,
    "Fixed malware rates": fixed_malware_rate
}


def save_classifier():

    if CLASSIFIER:

        try:
            os.mkdir("Classifiers")
        except FileExistsError:
            pass
        pickle_name = os.path.join("Classifiers", "classifier_pickle")
        with open(pickle_name, 'wb') as pickle_file:
            pickle.dump(CLASSIFIER, pickle_file)

    else:
        classifier_does_not_exist_error()


def save_report(mr_train, mr_test, d_name="Cuckoo JSON"):

    classifier_name = type(CLASSIFIER).__name__

    classifier_names = (i.__name__ for i in list(CLASSIFIER_DICT.values()))

    if classifier_name in classifier_names:

        try:
            malware_rate_train = mr_train
            malware_rate_test = mr_test
        except ValueError:
            print("Malware rates have to be floating point values.")
            return

        dataset_name = d_name
        accuracy = CLASSIFIER.accuracy
        CLASSIFIER.create_confusion_matrix(PARTITIONED_DATA_DICT["Testing labels"])
        conf_matrix_norm = CLASSIFIER.normalized_confusion_matrix
        conf_matrix_unnorm = CLASSIFIER.unnormalized_confusion_matrix

        REPORT.build_report(classifier_name, dataset_name, malware_rate_train, malware_rate_test, accuracy,
                            conf_matrix_norm, conf_matrix_unnorm)

        REPORT.save_report()

    else:
        print(f"Classifier {classifier_name} does not exist.")


def feature_extraction(extraction_type):
    """
    Selects the appropriate feature extraction algorithm from the extraction dictionary
    according to extraction_type and runs it.
    :except KeyError: when extraction_type is not in EXTRACTOR_DICT.
    :param extraction_type: Type of feature extraction to be performed as String.
    :return: None.
    """
    try:
        extractor = EXTRACTOR_DICT[extraction_type]()
        extractor.extract_features()

    except KeyError:
        print(f"Feature extraction type {extraction_type} is not available.")


def load_json_data(malware_rate):
    """
    Loads the json data set from the csv file into memory.
    :param malware_rate: The amount of malware present in the data represented as a float.
    :return: None.
    """
    DATA_MANAGER.load_data(malware_rate)


def partition_data(size_of_test_set):
    """
    Partition the data into training and testing sets.
    :param size_of_test_set: Float representing the size of the testing set.
    :return: None.
    """
    PARTITIONED_DATA_DICT["Training data"], PARTITIONED_DATA_DICT["Testing data"], \
        PARTITIONED_DATA_DICT["Training labels"], PARTITIONED_DATA_DICT["Testing labels"] = \
        DATA_MANAGER.partition_data(size_of_test_set)


def select_classifier(classifier_name):
    """
    Selects the appropriate classifier from CLASSIFIER_DICT and instantiates it.
    :except KeyError: if classifier_name is not in CLASSIFIER_DICT.
    :param classifier_name: String representing the name of the classifier to select.
    :return: None.
    """
    try:
        global CLASSIFIER
        CLASSIFIER = CLASSIFIER_DICT[classifier_name](REPORT.curr_report_dir)

    except KeyError:
        print(f"Classifier {classifier_name} is not available.")

    else:
        return classifier_name  # Only return classifier_name if nothing goes wrong.


def train_classifier():
    """
    Trains the classifier.
    :return: None or classifier_does_not_exist_error message.
    """
    if CLASSIFIER:  # TODO: ValueError when data not loaded.
        CLASSIFIER.fit(PARTITIONED_DATA_DICT["Training data"], PARTITIONED_DATA_DICT["Training labels"])
    return classifier_does_not_exist_error()


def classify_new_data():
    """
    :return: Returns the predicted labels in a list.
    """
    if CLASSIFIER:
        try:
            CLASSIFIER.predict(PARTITIONED_DATA_DICT["Testing data"])
        except NotFittedError:
            print("This DecisionTreeClassifier instance is not fitted yet.")

        return CLASSIFIER.predicted_labels

    return classifier_does_not_exist_error()


def calculate_classifier_accuracy():
    """
    sklearn.exceptions.NotFittedError: This DecisionTreeClassifier instance is not fitted yet.
    Call 'fit' with appropriate arguments before using this method.
    :return: Returns the classifier's accuracy as a float.
    """
    if CLASSIFIER:
        CLASSIFIER.calculate_accuracy(PARTITIONED_DATA_DICT["Testing data"], PARTITIONED_DATA_DICT["Testing labels"])
        return CLASSIFIER.accuracy

    return classifier_does_not_exist_error()


def cross_validate(k_fold):  # return error code?
    """
    ValueError: Found array with 0 sample(s) (shape=(0,)) while a minimum of 1 is required. (no data loaded)

    Classify data using cross validation.
    :param k_fold: integer representing the number of partitions applied during cross validation.
    :return: The cross validation score as a list of lists.
    """
    if CLASSIFIER:  # TODO: ValueError when data not loaded.

        try:
            CLASSIFIER.cross_validate(DATA_MANAGER.features, DATA_MANAGER.labels, k_fold)
            return CLASSIFIER.cross_score

        except ValueError:
            return "k_fold value must be an integer."

    return classifier_does_not_exist_error()


def display_confusion_matrix():  # TODO: does not display confusion matrix.
    """
    Plots the confusion matrix as an image.
    :return: None.
    """
    REPORT.create_new_report_directory()

    if CLASSIFIER:
        CLASSIFIER.export_as_pdf(DATA_MANAGER.feature_names, DATA_MANAGER.label_names)
        CLASSIFIER.display_confusion_matrix(PARTITIONED_DATA_DICT["Testing labels"], DATA_MANAGER.label_names)

    return classifier_does_not_exist_error()


def classifier_does_not_exist_error():  # Is this necessary ?
    return "Error: Could not perform operation because no classifier is selected. " \
           "Please select a classifier from the classifier menu."


def run_selected_benchmark(benchmark_type, *args):
    """
    Runs the selected benchmark function according to benchmark_type.
    :except TypeError: is thrown if number of arguments does not match required amount.
    :except KeyError: is thrown if selected function does not exist in dictionary.
    :param benchmark_type: benchmark name as String.
    :return: None.
    """
    try:
        params = []
        # Parameters need to be converted from strings to float values
        for i in args:
            try:
                params.append(float(i))

            except ValueError:  # If the value was meant to be a string
                params.append(i)

        BENCHMARKS_DICT[benchmark_type](DATA_MANAGER, *params, CLASSIFIER)

    except TypeError:
        print(f"Error: {benchmark_type} does not take {len(args)} arguments.")

    except KeyError:
        print(f"Error: Could not perform operation because no benchmark of type {benchmark_type} exists. "
              f"Please select a valid benchmark option.")

    except ValueError:  # remove ???
        print("Error: Arguments must be float point values")


def list_reports():
    print(f"\nList of saved reports:\n{REPORT.list_reports()}\n")


def list_saved_classifiers():
    return


def open_report(report_num):  # TODO: Big error message ???

    path_to_csv = os.path.join(os.path.join(REPORT.report_dir, report_num), "report.csv")
    path_to_pdf = os.path.join(os.path.join(REPORT.report_dir, report_num), "Decision_Tree.pdf")
    path_to_unnorm = os.path.join(os.path.join(REPORT.report_dir, report_num), "Unnormalized Confusion Matrix.png")
    path_to_norm = os.path.join(os.path.join(REPORT.report_dir, report_num), "Normalized Confusion Matrix.png")

    subprocess.Popen(["libreoffice", "--calc", path_to_csv])
    subprocess.run(["gio", "open", path_to_pdf])
    subprocess.run(["gio", "open", path_to_unnorm])
    subprocess.run(["gio", "open", path_to_norm])


def merge_reports():
    REPORT.create_master_report()


def load_classifier():

    with open(os.path.join("Classifiers", "classifier_pickle"), 'rb') as pickle_file:
        global CLASSIFIER
        CLASSIFIER = pickle.load(pickle_file)


def cuckoo_sandbox():
    """
    :return:
    """
    print("No implemented!")  # TODO: make it possible to launch cuckoo in another terminal from this program.
    # fifo = "fifo"    /home/marcus/PycharmProjects/Final_Project/launchCuckoo.py
    # os.mkfifo(fifo)
    # cuckoo_terminal = True
    # subprocess.Popen(["gnome-terminal", "--=echo 'test'"])
    # with open(fifo, "wb") as pipe:
    #     pipe.write()
    # os.system("./home/marcus/PycharmProjects/Final_Project/launchCuckoo.sh &")
    #  subprocess.run("/home/marcus/PycharmProjects/Final_Project/launchCuckoo.sh")
    # cmd_line = "/home/marcus/PycharmProjects/Final_Project/launchCuckoo.sh"
    # p = subprocess.Popen(cmd_line, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    # new_terminal = subprocess.Popen("/home/marcus/PycharmProjects/Final_Project/launchCuckoo.sh", shell=True,
    # stdout=subprocess.STDOUT, stderr=subprocess.STDOUT)
    # out = new_terminal.communicate()[0]
    # print(out)
    # outs, errs = new_terminal.communicate(input="/home/marcus/PycharmProjects/Final_Project/launchCuckoo.sh")
    # print(f"{outs}, {errs}")
    # subprocess.run(["gnome-terminal", "./home/marcus/PycharmProjects/Final_Project/launchCuckoo.sh &"])
    # subprocess.run()
    # subprocess.run("./load Cuckoo.sh")


def exception_handler():
    return
