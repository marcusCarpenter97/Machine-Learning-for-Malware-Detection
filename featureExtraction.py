
import json
import os
import re
import traceback


class FeatureExtraction:

    def __init__(self):
        self.data_set_directory = "/home/marcus/PycharmProjects/Final_Project/JSON reports"
        self.mist_data_directory = "/home/marcus/PycharmProjects/Final_Project/MIST reports"
        self.path_to_csv_data_file = "/home/marcus/PycharmProjects/Final_Project/extracted_json_data.csv"
        self.path_to_mist_csv = "/home/marcus/PycharmProjects/Final_Project/extracted_mist_data.csv"
        self.csv_header = "duration, score, av count, process count, signature count, report size, is malware\n"
        self.error_log_path = "/home/marcus/PycharmProjects/Final_Project/error_log"

    """Could be replaced by string == 'True'"""
    def str_to_bool(self, s):
        if s == "True":
            return True
        else:
            return False

    def sort_csv(self):

        try:
            with open(self.path_to_csv_data_file) as csv_file:
                csv_file.readline()
                text = csv_file.read().splitlines()

            arr = []
            for line in text:
                arr.append(line.split(", "))

            count = [0, 0]  # False, True
            sorted_csv = [0] * len(arr)

            for i in arr:
                count[self.str_to_bool(i[6])] += 1

            count[True] += count[False]

            for i in reversed(arr):
                sorted_csv[count[self.str_to_bool(i[6])] - 1] = i
                count[self.str_to_bool(i[6])] -= 1

            os.remove(self.path_to_csv_data_file)

            for line in sorted_csv:
                self.build_csv(line[0], line[1], line[2], line[3], line[4], line[5], line[6])

        except IOError:
            print(traceback.format_exc())

    def log_errors(self, file, error):
        with open(self.error_log_path, "a") as err_log:
            err_log.write(f"{file}\n")
            err_log.write(f"{error}\n")

    def build_csv(self, duration, score, av_count, processes_count, signature_count, report_size, is_malware, ):

        row_to_write = f"{duration}, {score}, {av_count}, {processes_count}, {signature_count}, {report_size}, {is_malware}\n"

        if not os.path.isfile(self.path_to_csv_data_file):
            with open(self.path_to_csv_data_file, "a") as csv_data:
                csv_data.write(self.csv_header)

        with open(self.path_to_csv_data_file, "a") as csv_data:
            csv_data.write(row_to_write)

    def extract_cuckoo_logs(self, json_data):
            return json_data["debug"]["cuckoo"]

    def extract_duration(self, json_data):
        return json_data["info"]["duration"]

    def extract_score(self, json_data):
        return json_data["info"]["score"]

    def extract_av_detection_count(self, json_data):
        av_detected_count = 0

        for key, item in json_data["virustotal"]["scans"].items():
            if item[list(item.keys())[0]]:
                av_detected_count += 1

        return av_detected_count

    def extract_num_of_processes(self, json_data):
        process_count = 0

        cuckoo_logs = self.extract_cuckoo_logs(json_data)
        for line in cuckoo_logs:
            if re.search(r'New process', line):
                process_count += 1

        return process_count

    def extract_num_of_signature_matches(self, json_data):
        signature_match_count = 0

        cuckoo_logs = self.extract_cuckoo_logs(json_data)
        for line in cuckoo_logs:
            if re.search(r'Analysis matched signature:', line):
                signature_match_count += 1

        return signature_match_count

    def extract_type_of_report(self, report_name):
        if re.match(r'malware', report_name):
            return True
        return False

    def extract_file_size(self, file):
        return os.stat(os.path.join("JSON reports", file)).st_size

    def extract_features(self):

        json_files = os.listdir(self.data_set_directory)
        progress_counter = 0

        for json_name in json_files:

            progress_counter += 1

            print(f"Current file: {json_name} Current progress: {progress_counter}/{len(json_files)}   {(progress_counter/len(json_files))*100}%")

            json_path = os.path.join(self.data_set_directory, json_name)

            if self.extract_file_size(json_name) < 1073741824:

                try:
                    with open(json_path) as json_file:
                        json_data = json.load(json_file)

                        self.build_csv(
                            self.extract_duration(json_data),
                            self.extract_score(json_data),
                            self.extract_av_detection_count(json_data),
                            self.extract_num_of_processes(json_data),
                            self.extract_num_of_signature_matches(json_data),
                            self.extract_file_size(json_name),
                            self.extract_type_of_report(json_name))

                except (IOError, KeyError):
                    self.log_errors(json_name, traceback.format_exc())
            else:
                self.log_errors(json_name, "File over 1GB")

        self.sort_csv()

    def extract_mist(self):
        """
        BigO(n*m) where n = number of files and m = line count per file
        :return:
        """

        mist_data = []

        mist_files = os.listdir(self.mist_data_directory)

        mist_files_len = len(mist_files)

        progress_counter = 0

        for file_name in mist_files:

            progress_counter += 1

            print(f"Current file: {file_name} Current progress: {progress_counter}/{mist_files_len}   {(progress_counter/mist_files_len)*100}%")

            mist_report = []

            # Get file type from file name to label report
            file_type = re.match(r'malware|benign', file_name).group()

            file_path = os.path.join(self.mist_data_directory, file_name)

            try:
                with open(file_path, 'r') as report:

                    for line in report:
                        # Match line with regular expression.
                        new_mist_code = re.match(r'\d\d \d\d', line)

                        # If regex finds a match then create new report
                        if new_mist_code:
                            mist_report.append(new_mist_code.group())

                    mist_report.append(file_type)
                    mist_data.append(mist_report)

            except IOError:
                print("IOError")

        with open(self.path_to_mist_csv, "w") as mist_csv:
            mist_csv.write(",".join(str(item) for row in mist_data for item in row))
