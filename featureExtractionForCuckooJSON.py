
import json
import os
import re
import traceback


class CuckooJsonFeatureExtractor(object):

    def __init__(self):
        self.json_data_directory = "/home/marcus/PycharmProjects/Final_Project/JSON reports"
        self.csv_data_destination = "/home/marcus/PycharmProjects/Final_Project/extracted_json_data.csv"
        self.csv_header = "duration, score, antivirus count, process count, signature count, report size, is malware\n"
        self.error_log_path = "/home/marcus/PycharmProjects/Final_Project/error_log"
        self.file_size_limit = 1073741824  # In bytes

    def sort_csv(self):
        """
        Use a Counting Sort algorithm to sort the data in the csv.
        Worst case performance: O(n + k) where n= num of items and k=num of classes
        Throws IOError exception if csv file does not exist.
        :return: None
        """

        try:
            with open(self.csv_data_destination) as csv_file:
                csv_file.readline()
                text = csv_file.read().splitlines()

            # Convert text to array
            text_as_arr = []
            for line in text:
                text_as_arr.append(line.split(", "))

            ft_count = [0, 0]  # False, True
            sorted_csv = [0] * len(text_as_arr)

            # Count 'True' and 'False' in array
            for i in text_as_arr:
                ft_count[i[6] == "True"] += 1

            # Get range of 'True' and 'False' in array
            ft_count[True] += ft_count[False]

            # Add elements to sorted_csv in the correct order order creating a sorted array
            for i in reversed(text_as_arr):
                class_label = i[6] == "True"

                sorted_csv[ft_count[class_label] - 1] = i
                ft_count[class_label] -= 1

            # Re-build the csv file with the sorted data
            os.remove(self.csv_data_destination)

            for line in sorted_csv:
                self.build_csv(line[0], line[1], line[2], line[3], line[4], line[5], line[6])

        except IOError:
            print(traceback.format_exc())

    def log_errors(self, file, error):

        with open(self.error_log_path, "a") as err_log:
            err_log.write(f"{file}\n")
            err_log.write(f"{error}\n")

    def build_csv(self, duration, score, antivirus_count, processes_count, signature_count, report_size, is_malware):

        row_to_write = (f"{duration}, {score}, {antivirus_count}, {processes_count}, {signature_count}, "
                        f"{report_size}, {is_malware}\n")

        # If file does not exist then create a new one
        if not os.path.isfile(self.csv_data_destination):
            with open(self.csv_data_destination, "a") as csv_data:
                csv_data.write(self.csv_header)

        with open(self.csv_data_destination, "a") as csv_data:
            csv_data.write(row_to_write)

    def extract_cuckoo_logs(self, json_data):
            return json_data["debug"]["cuckoo"]

    def extract_duration(self, json_data):
        return json_data["info"]["duration"]

    def extract_score(self, json_data):
        return json_data["info"]["score"]

    def extract_antivirus_detection_count(self, json_data):
        antivirus_detection_count = 0

        for key, item in json_data["virustotal"]["scans"].items():
            if item[list(item.keys())[0]]:
                antivirus_detection_count += 1

        return antivirus_detection_count

    def extract_num_of_processes(self, json_data):
        process_count = 0

        cuckoo_logs = self.extract_cuckoo_logs(json_data)
        for line in cuckoo_logs:
            if re.search(r'New process', line):
                process_count += 1

        return process_count

    def extract_num_of_signature_matches(self, json_data):
        signature_match_count = 0

        cuckoo_logs = self.extract_cuckoo_logs(json_data)
        for line in cuckoo_logs:
            if re.search(r'Analysis matched signature:', line):
                signature_match_count += 1

        return signature_match_count

    def extract_type_of_report(self, report_name):
        if re.match(r'malware', report_name):
            return True
        return False

    def extract_file_size(self, file):
        return os.stat(os.path.join("JSON reports", file)).st_size

    def extract_features(self):

        json_files = os.listdir(self.json_data_directory)
        progress_counter = 0

        for json_name in json_files:

            progress_counter += 1

            print(f"Current file: {json_name} Current progress: {progress_counter}/{len(json_files)}   "
                  f"{(progress_counter/len(json_files))*100}%")

            json_path = os.path.join(self.json_data_directory, json_name)

            if self.extract_file_size(json_name) < self.file_size_limit:

                try:
                    with open(json_path) as json_file:
                        json_data = json.load(json_file)

                        self.build_csv(
                            self.extract_duration(json_data),
                            self.extract_score(json_data),
                            self.extract_antivirus_detection_count(json_data),
                            self.extract_num_of_processes(json_data),
                            self.extract_num_of_signature_matches(json_data),
                            self.extract_file_size(json_name),
                            self.extract_type_of_report(json_name))

                except (IOError, KeyError):
                    self.log_errors(json_name, traceback.format_exc())
            else:
                self.log_errors(json_name, "File over 1GB")

        self.sort_csv()