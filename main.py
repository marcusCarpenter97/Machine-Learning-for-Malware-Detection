# machine learning framework
from dataset import Dataset
from featureExtractionForCuckooJSON import CuckooJsonFeatureExtractor
from featureExtractionForMIST import MistFeatureExtractor

# this class: set up data, feature extraction, classifier, benchmarks, interact with bash scripts at request of user
# new class: client interface - select options

# Dictionary containing all the available feature extraction classes with their respective labels.
extractor_dict = {
    "Cuckoo JSON": CuckooJsonFeatureExtractor,
    "MIST": MistFeatureExtractor
}


def feature_extraction(extraction_type):
    """
    Selects the appropriate feature extraction algorithm from the extraction dictionary
    according to extraction_type and runs it.
    Current feature extraction algorithms available: 'Cuckoo JSON', 'MIST'
    Throws KeyError exception if extraction_type is not in extractor_dict
    :param extraction_type: type of feature extraction to be performed as String
    :return: None
    """
    try:
        extractor = extractor_dict[extraction_type]()
        extractor.extract_features()

    except KeyError:
        print(f"{extraction_type} is not available as a feature extraction method.")


def fixed_malware_rate_benchmarks(training_malware_rate, test_malware_rates, test_size):

    # load data 100%
    # partition data at 0.33
    # adjust training partition
    # adjust test partition


    data = Dataset()
    data.load_data(training_malware_rate)

    print(f"Decision Tree trained with : {training_malware_rate} malware rate")
    training_data, testing_data, training_labels, testing_labels = data.partition_data(test_size)

    tree_classifier = DecisionTreeClassifier()
    tree_classifier.fit(training_data, training_labels)

    for test_rate in test_malware_rates:
        print(f"Decision Tree tested with : {test_rate} malware rate")
        data = Dataset()
        data.load_data(test_rate)
        training_data, testing_data, training_labels, testing_labels = data.partition_data(test_size)
        tree_classifier.predict(testing_data)
        tree_classifier.create_confusion_matrix(testing_labels, data.label_names)
        tree_classifier.calculate_accuracy(testing_data, testing_labels)
        tree_classifier.export_tree_as_pdf(data.feature_names, data.label_names)

        print(f"Accuracy: {tree_classifier.accuracy}")
        dysplay_confusion_matrix(testing_labels, tree_classifier.predicted_labels, data.label_names)
        break

malware_rate = 0.01
test_set_size = 0.33
k_fold = 5
high_malware_rates = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1]
low_malware_rates = [0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08, 0.09, 0.1]

fixed_malware_rate_benchmarks(malware_rate, low_malware_rates, test_set_size)

"""
data = Dataset()
data.load_data(malware_rate)

training_data, testing_data, training_labels, testing_labels = data.partition_data(test_set_size)

tree_classifier = DecisionTreeClassifier()
# forest_classifier = RandomForestClassifier()

tree_classifier.fit(training_data, training_labels)
# forest_classifier.fit(training_data, training_labels)

tree_classifier.calculate_accuracy(testing_data, testing_labels)
# forest_classifier.calculate_accuracy(testing_data, testing_labels)

tree_classifier.cross_validate(data.features, data.labels, k_fold)
# forest_classifier.cross_validate(data.features, data.labels, k_fold)

tree_classifier.predict(testing_data)
# forest_classifier.predict(testing_data)

tree_classifier.create_confusion_matrix(testing_labels, data.label_names)
# forest_classifier.create_confusion_matrix(testing_labels, data.label_names)

tree_classifier.export_tree_as_pdf(data.feature_names, data.label_names)

dysplay_confusion_matrix()
"""